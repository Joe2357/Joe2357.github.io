---
title: "[BOJ 16928] 뱀과 사다리 게임"
author: Joe2357
categories: [Problem Solving, Baekjoon]
tags: [Baekjoon]
uploaded_at: 2021-05-17 23:35:35 +0900
last_modified_at: 2023-01-21 23:42:46 +0900
description: "- 문제풀이"
math: true
---

> 문제 링크 : [https://www.acmicpc.net/problem/16928](https://www.acmicpc.net/problem/16928)


### 문제

<p><a href="https://en.wikipedia.org/wiki/Snakes_and_Ladders">뱀과 사다리 게임</a>을 즐겨 하는 큐브러버는 어느 날 궁금한 점이 생겼다.</p>
<blockquote>
<p>주사위를 조작해 내가 원하는 수가 나오게 만들 수 있다면, 최소 몇 번만에 도착점에 도착할 수 있을까?</p>
</blockquote>
<p>게임은 정육면체 주사위를 사용하며, 주사위의 각 면에는 1부터 6까지 수가 하나씩 적혀있다. 게임은 크기가 10×10이고, 총 100개의 칸으로 나누어져 있는 보드판에서 진행된다. 보드판에는 1부터 100까지 수가 하나씩 순서대로 적혀져 있다.</p>
<p>플레이어는 주사위를 굴려 나온 수만큼 이동해야 한다. 예를 들어, 플레이어가 i번 칸에 있고, 주사위를 굴려 나온 수가 4라면, i+4번 칸으로 이동해야 한다. 만약 주사위를 굴린 결과가 100번 칸을 넘어간다면 이동할 수 없다. 도착한 칸이 사다리면, 사다리를 타고 위로 올라간다. 뱀이 있는 칸에 도착하면, 뱀을 따라서 내려가게 된다. 즉, 사다리를 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 크고, 뱀을 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 작아진다.</p>
<p>게임의 목표는 1번 칸에서 시작해서 100번 칸에 도착하는 것이다.</p>
<p>게임판의 상태가 주어졌을 때, 100번 칸에 도착하기 위해 주사위를 굴려야 하는 횟수의 최솟값을 구해보자.</p>



### 입력

<p>첫째 줄에 게임판에 있는 사다리의 수 N(1 ≤ N ≤ 15)과 뱀의 수 M(1 ≤ M ≤ 15)이 주어진다.</p>
<p>둘째 줄부터 N개의 줄에는 사다리의 정보를 의미하는 x, y (x &lt; y)가 주어진다. x번 칸에 도착하면, y번 칸으로 이동한다는 의미이다.</p>
<p>다음 M개의 줄에는 뱀의 정보를 의미하는 u, v (u &gt; v)가 주어진다. u번 칸에 도착하면, v번 칸으로 이동한다는 의미이다.</p>
<p>1번 칸과 100번 칸은 뱀과 사다리의 시작 또는 끝이 아니다. 모든 칸은 최대 하나의 사다리 또는 뱀을 가지고 있으며, 동시에 두 가지를 모두 가지고 있는 경우는 없다. 항상 100번 칸에 도착할 수 있는 입력만 주어진다.</p>



### 출력

<p>100번 칸에 도착하기 위해 주사위를 최소 몇 번 굴려야 하는지 출력한다.</p>



### 제한

| 시간 제한 | 메모리 제한 |
| :-------: | :---------: |
| 1sec | 512MB |



---


### 풀이

1번 칸에서 시작하여 100번 칸에 도달하기 위한 최소 주사위 굴리기 횟수를 구하는 문제다. 모든 간선의 가중치가 1(주사위 1회)인 그래프에서 최단 거리를 찾는 것과 같으므로, [BFS 탐색](https://en.wikipedia.org/wiki/Breadth-first_search)을 활용하여 효율적으로 해결할 수 있다.


해결 과정은 다음과 같다:

* **보드판 구성**: 1부터 100까지의 칸을 배열로 관리하며, 사다리와 뱀의 정보를 별도의 배열에 저장하여 특정 칸에 도착했을 때 즉시 이동할 수 있도록 구성한다.
* **큐 초기화**: 시작점인 1번 칸과 현재까지 주사위를 굴린 횟수(0회)를 큐에 삽입하고 방문 처리를 진행한다.
* **탐색 진행**: 큐에서 현재 위치를 꺼내 주사위를 굴려 나올 수 있는 모든 경우를 확인한다. 주사위의 눈금 $i$는 다음과 같은 범위를 갖는다:


$$
1 \le i \le 6
$$


* **이동 및 점프 처리**: 주사위를 굴려 도달한 칸에 사다리나 뱀이 존재한다면, 정의된 목적지 좌표로 즉시 이동시킨다. 이동한 최종 위치가 아직 방문하지 않은 곳이라면 큐에 추가하고 방문 여부를 기록한다.
* **최단 거리 보장**: BFS의 특성상 100번 칸에 가장 먼저 도달하는 경로가 주사위를 최소로 굴린 횟수를 보장한다. 해당 목표 지점에 도달하는 순간 연산을 멈추고 결과를 출력한다.

총 100개의 정점에 대해 각 정점당 최대 6개의 간선이 존재하므로 전체 시간 복잡도는 $O(V+E)$가 되며, 이는 제한 시간 1초 내에 매우 여유롭게 수행 가능하다.


### 소스코드

> Github Link : [Source Code](https://github.com/Joe2357/Baekjoon/blob/master/C/Code/16900/16928.c)
>
> 참고 알고리즘 : [BFS 탐색](https://en.wikipedia.org/wiki/Breadth-first_search)