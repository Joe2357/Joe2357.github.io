---
title: "[BOJ 15686] 치킨 배달"
author: Joe2357
categories: [Problem Solving, Baekjoon]
tags: [Baekjoon]
uploaded_at: 2021-10-29 17:32:29 +0900
last_modified_at: 2023-01-22 13:14:29 +0900
description: "- 문제풀이"
math: true
---

> 문제 링크 : [https://www.acmicpc.net/problem/15686](https://www.acmicpc.net/problem/15686)


### 문제

<p>크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미한다. r과 c는 1부터 시작한다.</p>
<p>이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 "<strong>치킨 거리</strong>"라는 말을 주로 사용한다. <strong>치킨 거리</strong>는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 <strong>치킨 거리</strong>를 가지고 있다. <strong>도시의 치킨 거리</strong>는 모든 집의 <strong>치킨 거리</strong>의 합이다.</p>
<p>임의의 두 칸 (r<sub>1</sub>, c<sub>1</sub>)과 (r<sub>2</sub>, c<sub>2</sub>) 사이의 거리는 |r<sub>1</sub>-r<sub>2</sub>| + |c<sub>1</sub>-c<sub>2</sub>|로 구한다.</p>
<p>예를 들어, 아래와 같은 지도를 갖는 도시를 살펴보자.</p>
<pre>

0 2 0 1 0

1 0 1 0 0

0 0 0 0 0

0 0 0 1 1

0 0 0 1 2

</pre>
<p>0은 빈 칸, 1은 집, 2는 치킨집이다.</p>
<p>(2, 1)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |2-1| + |1-2| = 2, (5, 5)에 있는 치킨집과의 거리는 |2-5| + |1-5| = 7이다. 따라서, (2, 1)에 있는 집의 치킨 거리는 2이다.</p>
<p>(5, 4)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |5-1| + |4-2| = 6, (5, 5)에 있는 치킨집과의 거리는 |5-5| + |4-5| = 1이다. 따라서, (5, 4)에 있는 집의 치킨 거리는 1이다.</p>
<p>이 도시에 있는 치킨집은 모두 같은 프랜차이즈이다. 프렌차이즈 본사에서는 수익을 증가시키기 위해 일부 치킨집을 폐업시키려고 한다. 오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는  치킨집의 개수는 최대 M개라는 사실을 알아내었다.</p>
<p>도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, <strong>도시의 치킨 거리</strong>가 가장 작게 될지 구하는 프로그램을 작성하시오.</p>



### 입력

<p>첫째 줄에 N(2 ≤ N ≤ 50)과 M(1 ≤ M ≤ 13)이 주어진다.</p>
<p>둘째 줄부터 N개의 줄에는 도시의 정보가 주어진다.</p>
<p>도시의 정보는 0, 1, 2로 이루어져 있고, 0은 빈 칸, 1은 집, 2는 치킨집을 의미한다. 집의 개수는 2N개를 넘지 않으며, 적어도 1개는 존재한다. 치킨집의 개수는 M보다 크거나 같고, 13보다 작거나 같다.</p>



### 출력

<p>첫째 줄에 폐업시키지 않을 치킨집을 최대 M개를 골랐을 때, 도시의 치킨 거리의 최솟값을 출력한다.</p>



### 제한

| 시간 제한 | 메모리 제한 |
| :-------: | :---------: |
| 1sec | 512MB |



---


### 풀이

도시의 치킨 거리를 최소화하기 위해 전체 치킨집 중 최대 $M$개를 선택하는 최적의 조합을 찾는 문제다. 도시에 있는 치킨집의 개수는 최대 13개로 매우 적기 때문에, 가능한 모든 조합을 탐색하는 [브루트포스 알고리즘](https://en.wikipedia.org/wiki/Brute-force_search)과 [백트래킹 알고리즘](https://joe2357.github.io/posts/Backtracking/)을 사용하여 해결할 수 있다.

해결 과정은 다음과 같다:

1. **좌표 저장**: 도시의 정보를 입력받으면서 집(`1`)의 좌표와 치킨집(`2`)의 좌표를 각각 별도의 리스트(`home`, `chicken`)에 저장한다.
2. **조합 생성**: 백트래킹을 활용하여 전체 치킨집 중에서 $M$개를 선택하는 모든 경우의 수를 구한다. 소스 코드에서는 `select` 배열을 통해 어떤 치킨집이 폐업하지 않았는지 상태를 관리한다.
3. **치킨 거리 계산**: 각 조합에 대해 모든 집을 순회하며 가장 가까운 치킨집과의 거리를 계산한다. 임의의 두 칸 사이의 거리는 문제에서 제시된 **맨해튼 거리(Manhattan Distance)** 공식을 사용한다:




$$
dist(H, C) = |r_H - r_C| + |c_H - c_C|
$$


4. **최솟값 갱신**: 각 조합에서 계산된 '도시의 치킨 거리'(모든 집의 치킨 거리 합) 중 최솟값을 `retval`에 저장하여 최종적으로 출력한다.

치킨집의 최대 개수가 13개이므로 조합의 최대 개수는 $\sum_{m} \binom{13}{13-m}$이므로 대략 1만 정도에 불과하다. 각 조합마다 최대 100개의 집(`2N`)에 대해 거리 계산을 수행하므로, 제한 시간 1초 내에 충분히 연산을 마칠 수 있다.


### 소스코드

> Github Link : [Source Code](https://github.com/Joe2357/Baekjoon/blob/master/C/Code/15600/15686.c)
>
> 참고 알고리즘 : [브루트포스 알고리즘](https://en.wikipedia.org/wiki/Brute-force_search), [백트래킹 알고리즘](https://joe2357.github.io/posts/Backtracking/)